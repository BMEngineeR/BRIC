---
title: "BRIC vignette"
subtitle: BRIC 
abstract: BRIC integrates in-house and state-of-the-art computational tools and provides two analysis strategies, including LTMG (left-truncated mixture Gaussian model)-embedded scRNA-Seq analy-sis and co-expression gene analysis.
author: Yuzhou Chang
date: "26 February, 2020"
output:
  BiocStyle::html_document:
    number_sections: no
    toc: yes
    highlight: pygments
    
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Intorduction to BRIC

## General introduction 
BRIC integrates in-house and state-of-the-art computational tools and provides two analysis strategies, including LTMG (left-truncated mixture Gaussian model)-embedded scRNA-Seq analysis and co-expression gene analysis.

## Main function

The main idea of BRIC consists of two major strategies: 

* (i) LTMG-based scRNA-seq analysis
* (ii) co-expression gene module analysis.

## Obejct structure 
The computational frame is constructed under the S4 data structure in R. The structure of `BRIC object` is: 

- -**BRIC_Object:** *name of object is called BRIC.*
  - -**raw_count:** *raw data matrix (gene in row, cell in columns, prefer using gene symbol).*
  - -**processed_count:** *normalized and imputation (default: FALSE).*
  - -**Meta_info:** *cell classification information based on LTMG and Bicluster.*
  - -**Discretization:** *discretized matrix based on qubic 1.0, which prepares for microarry and bulk RNA-Seq analysis.*
  - -**LTMG:** *LTMG slot is for storing relative results from first strategy.*
    - -**LTMG_discrete:** *Condition assigned matrix, which is generating from LTMG model.*
    - -**LTMG_BinarySingleSignal:** *binary matrix based on gene “on /off.”*
    - -**LTMG_BinaryMultisignal:** *binary matrix based on multiple condition.*
    - -**DimReduce:** *include three dimension loading score, including PCA, Tsne, and UMAP*
    - -**MarkerGene:** *Marker gene based on cell type identified by Seurat clustering method.*
    - -**Pathway:** *based on marker gene.*
    - -**tmp.Seurat:** *temporary Seurat object. In this Seurat Object, the starting matrix is LTMG signalling matrix.*
  - -**Bicluster:** **
    - -**Coreg_gene:** *co-regulatory genes are stored in this slot as dataframe; the first column is gene name and the second column is module number.*
    - -**CoCond_cell:** *co-condition cell are stored in this slot as dataframe; the first column is cell name and the second column is module number.*
    - -**MarkerGene:** *Marker gene based on cell type identified by Markov chain clustering algorithm.*
    - -**Pathway:** *genes based on co-expression gene of gene module (from Coreg_gene).*





# Requirements
## Environment

We will assum you have the following installed:

* R (equal or greater than 3.5)

Pre-install packge
```{r pre_install, eval=FALSE, echo=TRUE}
install.packages(c('devtools', 'AdaptGauss', "pheatmap", 'mixtools','MCL', 'anocva', 
                   'qgraph','multtest','Rtools','ggpubr'))
BiocManager::install(c('org.Mm.eg.db', 'org.Hs.eg.db','clusterProfiler','DEsingle',
                       'DrImpute', 'scater', 'scran'))
devtools::install_github(repo = 'satijalab/seurat')
```
## Input

1. The input to BRIC is the single-cell RNA-seq expression matrix:

* Rows correspond to genes and columns correspond to cells.
* Expression units: the preferred expression values are RPKM/FPKM/CPM. 
* The data file should be tab delimited.
2. BRIC also accept output files from 10X CellRanger, includinhg a folder which contains three individual files and h5 file. 

## Others

When you perform co-expression analysis, it will output several intermediate files, thus please make sure that you have write permission to the folder where BRIC is located. 

# Installation

For installation, simply type the following command in your R console:
```{r install, eval=FALSE, echo=TRUE}
devtools::install_github("BMEngineeR/BRIC",force = T)
```

# Example dataset

This tutorial run on a real dataset to illustrate the results obtained at each step.

As example, we will use Yan's data, a dataset containing 90 cells and 20,214 genes from human embryo, to conduct cell type prediction.

> Yan, L. et al. Single-cell RNA-Seq profiling of human preimplantation embryos and embryonic stem cells. Nat. Struct. Mol. Biol. 20, 1131-1139 (2013)

The original expression matrix was downloaded from <https://s3.amazonaws.com/scrnaseq-public-datasets/manual-data/yan/nsmb.2660-S2.csv>. The expression is provided as RPKM value. For convenience, we removed the space in the column names and deleted the second column(Transcript_ID). The processed data is available at <https://github.com/zy26/BRICdata/blob/master/Example%20data/Yan_RPKM>.


# Input data, create BRIC object, add meta information, and preprocessing. 

BRIC can accepted 10X chromium input files, including a folder (contain gene name, cell name, and sparse matrix) and .h5 file.

## Input data


1. Read from .h5 file.

```{r h5_files, eval= TRUE, echo=TRUE}
InputMatrix <- BRIC::ReadFrom10X_h5("../inst/extdata/10X_5K/5k_pbmc_protein_v3_filtered_feature_bc_matrix.h5")
```

2. Read from 10X folder.

```{r folder, eval= TRUE, echo=TRUE}
InputMatrix <- BRIC::ReadFrom10X_folder("../inst/extdata/10X_3K/folder_10X/")
```

## Add meta information

1. Create BRIC object.

```{r create_object, eval= TRUE, echo=TRUE}
object <- BRIC::CreateBRICObject(InputMatrix)
```

2. Addmeta: this step can add customized cell label by user, the format of file passing to `meta.info` is data frame of which row name should be cell ID, and column name should be cell type.    
```{r add_metadata, eval= TRUE, echo=TRUE}
object <- BRIC::AddMeta(object, meta.info = NULL)
```

3. plotmeta: plot meta information based on RNA count and Feature number. This step is for the following subset step in terms of filtering out low quality data.    
```{r plot_metadata, eval= FALSE, echo=TRUE}
BRIC::PlotMeta(object)
```
![](C:/analysis_work\BRIC\LTMG_track\metaplot.png)

4. remove low quality data based on the previous plot.
```{r subset_data, eval= TRUE, echo=TRUE}
object <- BRIC::SubsetData(object , nFeature.upper=3000,nFeature.lower=100,
                         Counts.upper=10000,Counts.lower=100)
```

## Preprocesing 

This step is optional. User can choose perform normalization or imputation based on their need (default is closed both two methods). The normalization method is from package scran and can be opened by using parameter `normalization = 'LibrarySizeNormalization'`. The imputation method is from package DrImpute and can be opened by using parameter `IsImputation = TRUE`.
```{r ProcessData, eval= TRUE, echo=TRUE}
object <- BRIC::ProcessData(object, normalization = "LibrarySizeNormalization", IsImputation = FALSE, seed = 123)
```




# Run LTMG

the argument `Gene_use = 2000` is top variant genes which are selected to run LTMG. For LTMG strategy, we recommend to use top 2000 gene. On the contrary, for co-expression gene analysis, we recommend to use all gene by changing `Gene_use = "all"`. 
```{r run_LTMG, eval= TRUE, echo=TRUE}
# demo only run top 500 gene for saving time.
object <- BRIC::RunLTMG(object, Gene_use = 50, seed = 123)
```

# LTMG strategy

## Dimension Reduction
```{r Run_dimReduce, eval= TRUE, echo=TRUE}
# demo only run top 500 gene for saving time.
object <- BRIC::RunDimensionReduction(object, reduction = "umap")
```

## cluster
```{r Runclassfication, eval= TRUE, echo=TRUE}
# demo only run top 500 gene for saving time.
object <- BRIC::RunClassification(object,  k.param = 20, resolution = 0.5, algorithm = 1)
```

## plot dimension reduction plot
```{r run_plotDim, eval= FALSE, echo=TRUE}
# demo only run top 500 gene for saving time.
PlotDimension(object,reduction = "umap")
```
THis function need user to input gorup that want to plot on the figure. Input `4` means choose the Seurat0.5 group as cell label to plot.
![dim](C:/analysis_work\\BRIC\\LTMG_track\\PlotDimentsion.png)
![cluster](C:/analysis_work\BRIC\LTMG_track\cluster.png)

# Biclustering

BRCI can provide biclustering function, which is based on our in-house novel algorithm, QUBIC2 (<https://github.com/maqin2001/qubic2>). Here we will show the basic biclustering usage of BRIC using a $100 \times 90$ expression matrix extracted from Yan's data(available at <https://github.com/zy26/BRICdata/blob/master/Example%20data/Yan_sub.txt>). 

You can type the following command to run discretization + biclustering directly:
```{r biclustering,eval=FALSE,echo = TRUE}
setwd('/path/to/your/data')
library(BRIC)
# BRIC::qubic('Yan_sub.txt',R=TRUE)
```

This will output several files, and among them you will find one named  `Yan_sub.txt.chars.blocks`,which contains the predicted biclusters.

Or, you may first type the following command to discretized the data:
```{r discretize,eval=FALSE}
BRIC::qubic('Yan_sub.txt',R=TRUE,F=TRUE)
```

When this step is done(you will find some files, including `Yan_sub.txt.chars`), type the following command to run biclustering:
```{r biclustering2, eval=FALSE}
BRIC::qubic('Yan_sub.txt.chars',d=TRUE)
```
Which will also output a file named `Yan_sub.txt.chars.blocks`.

Note that the second way run discretization and biclustering seperately. Since discretization ususally take a long time, we recommend to use the second way. In this case, you can try biclustering parameters as needed based on the discretized data, avoiding wasting time on discretization.

(The default parameters in BRIC are k=13, f=0.85, c=0.90,o=5000, you may use other parameters as you like, just specify them in the argument, e.g., BRIC::qubic('Yan_sub.txt',R=TRUE,k=8,f=0.90,c=0.95,o=1000))

# Cell type prediction

The cell type prediction of BRIC is based on the biclustering results. In short, it will construct a weighted graph based on the biclusters and then do clustering on the weighted graph. Currently, we provide two commonly used clustering methods: MCL and spectral clustering.

To do cell type prediction, you can call the `final()`function, using expression matrix as input:

```{r,eval=FALSE, cell_type}

RST <-BRIC::final('Yan_RPKM',R=TRUE,method='MCL')
```

Which will automatically conduct `biclustering`and `cell type prediction`. Note that it may take quite a long time to finish, as the discretization step of the biclustering is time-consuming.

Or, you may first conduct `biclustering` and then provide the output *.chars* file to the`final()`function:
```{r discretize2,eval=FALSE}
# BRIC::qubic('Yan_RPKM',R=TRUE)
```
```{r two step}
#RST <-BRIC::final('Yan_RPKM.chars',d=TRUE,method='MCL') # Note that must add d=TRUE if use .chars as input
# head(RST)
```

Both ways will give you a list of predicted cell labels

Note:

* By default, BRIC use *MCL* clustering. You may choose spectral clustering, and if so,you also need to specify the number of cell types(e.g., 6). In that case, you need to to call the function in this way: `BRIC::final('Yan_RPKM.chars,d=TRUE,method='SC',K=6)`


If you have reference label at hand, you can calculate some external criteria to evaluate the agreement between predicted cell labels and reference labels:


```{r calculate ARI}
# library(mclust)
# library(clues)
# target <-read.table('Yan_cell_label.csv',header=T,sep=',')  # read reference label
# head(target)
# # judge if the cell names are consistent
# aa <-names(RST)
# bb <-target$Cell_type
# # if consistent, continue to calculate ARI ect
# if (identical(sort(aa),sort(as.character(bb)))=='TRUE'){
#   sorted <-RST[match(target$Cell_type,names(RST))] # sort the predicted label
#   ARI <-adjustedRandIndex(sorted,target$Cluster)  
#   RI <-adjustedRand(sorted,target$Cluster,randMethod='Rand')
#   FM <-adjustedRand(sorted,target$Cluster,randMethod='FM')
#   JI <-adjustedRand(sorted,target$Cluster,randMethod='Jaccard')
#   df <-data.frame(ARI=ARI, RandIndex=RI,FolkesMallow=FM, Jaccard=JI)
#   df
# }
```


Note

* the reference labels used in this example is avaiable at <https://github.com/zy26/BRICdata/blob/master/Example%20data/Yan_cell_label.csv>
* you may need to sort the predicted labels first
* make sure that the cell names used in predicted label and reference labels are consistent
